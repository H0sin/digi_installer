services:
  # ðŸŒ Reverse Proxy & Load Balancer (Traefik)
  traefik:
    build:
      context: ./traefik
      dockerfile: Dockerfile
    container_name: traefik
    restart: unless-stopped
    command:
      # API and Dashboard
      - --api.dashboard=true
      - --api.insecure=false
      # Enable ping endpoint for health checks
      - --ping=true
      # Entrypoints
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.traefik.address=:8080
      # Global HTTP to HTTPS redirect
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
      - --entrypoints.web.http.redirections.entrypoint.permanent=true
      # Providers
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=digitalbot_web
      - --providers.file.directory=/etc/traefik/dynamic
      - --providers.file.watch=true
      # Logging
      - --log.level=INFO
      - --log.format=json
      - --accesslog=true
      - --accesslog.format=json
      # Metrics
      - --metrics.prometheus=true
      - --metrics.prometheus.addEntryPointsLabels=true
      - --metrics.prometheus.addServicesLabels=true
      # Let's Encrypt HTTP-01 challenge (optimized for speed)
      - --certificatesresolvers.httpresolver.acme.email=${TRAEFIK_ACME_EMAIL}
      - --certificatesresolvers.httpresolver.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.httpresolver.acme.httpchallenge.entrypoint=web
      # Faster certificate acquisition
      - --certificatesresolvers.httpresolver.acme.keytype=EC256
      # Use Let's Encrypt staging for testing (comment out for production)
      # - --certificatesresolvers.httpresolver.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory
      # Let's Encrypt DNS-01 challenge for wildcard support (optimized)
      - --certificatesresolvers.dnsresolver.acme.email=${TRAEFIK_ACME_EMAIL}
      - --certificatesresolvers.dnsresolver.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.dnsresolver.acme.dnschallenge=true
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.provider=${ACME_DNS_PROVIDER:-cloudflare}
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.delaybeforecheck=10
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.resolvers=1.1.1.1:53,8.8.8.8:53
      - --certificatesresolvers.dnsresolver.acme.keytype=EC256
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"  # Dashboard port
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik-letsencrypt:/letsencrypt
    environment:
      # DNS provider credentials for wildcard certs
      - CF_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
      - CLOUDFLARE_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
      # Environment variables for template processing
      - TRAEFIK_ACME_EMAIL=${TRAEFIK_ACME_EMAIL}
      - TRAEFIK_ADMIN_AUTH=${TRAEFIK_ADMIN_AUTH}
      - TRAEFIK_DASHBOARD_AUTH=${TRAEFIK_DASHBOARD_AUTH}
      - ACME_DNS_PROVIDER=${ACME_DNS_PROVIDER:-cloudflare}
      - EXTERNAL_API_URL=${EXTERNAL_API_URL}
    networks:
      - digitalbot_web
    # Traefik should start independently for faster SSL certificate acquisition
    # No dependencies needed - this improves startup time and SSL cert speed
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://localhost:8080/ping || curl -fsS http://localhost:8080/ping > /dev/null || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    labels:
      - traefik.enable=true
      # Dashboard router
      - traefik.http.routers.traefik.rule=Host(`${TRAEFIK_DOMAIN:-traefik.localhost}`)
      - traefik.http.routers.traefik.entrypoints=websecure
      - traefik.http.routers.traefik.tls=true
      - traefik.http.routers.traefik.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.traefik.service=api@internal
      - traefik.http.routers.traefik.middlewares=default-security@file,dashboard-auth@file
      # Dashboard service uses port 8080
      - traefik.http.services.traefik.loadbalancer.server.port=8080
  
  # âš›ï¸ React Client App
  client-app:
    image: ${CLIENT_APP_IMAGE}
    container_name: ${COMPOSE_PROJECT_NAME}-client-app
    restart: unless-stopped
    networks:
      - digitalbot_web
    environment:
      - VITE_BASE_API=${VITE_BASE_API}
    healthcheck:
      test: ["CMD-SHELL", "(curl -fsS http://localhost:3000/ || wget -q -O - http://localhost:3000/) > /dev/null 2>&1 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 6
      start_period: 40s
    labels:
      - traefik.enable=true
      - traefik.http.routers.client.rule=Host(`${CLIENT_APP_DOMAIN}`)
      - traefik.http.routers.client.entrypoints=websecure
      - traefik.http.routers.client.tls=true
      - traefik.http.routers.client.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.client.middlewares=default-security@file,rate-limit@file
      - traefik.http.services.client.loadbalancer.server.port=3000

  # ðŸŒ Main ASP.NET Core Web App
  webapp:
    image: ${WEBAPP_IMAGE}
    container_name: ${COMPOSE_PROJECT_NAME}-app
    restart: unless-stopped
    # Add resource limits to prevent crashes
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
    environment:
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - DOMAIN=${DOMAIN}
      - CLIENT_APP_DOMAIN=${CLIENT_APP_DOMAIN}
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
      # Add debugging environment variables
      - ASPNETCORE_URLS=http://+:8080
      - DOTNET_USE_POLLING_FILE_WATCHER=1
      - DOTNET_RUNNING_IN_CONTAINER=true
    networks:
      - digitalbot_web
      - digitalbot_internal
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:8080/healthz > /dev/null || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 6
      start_period: 60s
    labels:
      - traefik.enable=true
      - traefik.http.routers.webapp.rule=Host(`${DOMAIN}`)
      - traefik.http.routers.webapp.entrypoints=websecure
      - traefik.http.routers.webapp.tls=true
      - traefik.http.routers.webapp.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.webapp.middlewares=default-security@file,rate-limit@file
      - traefik.http.services.webapp.loadbalancer.server.port=8080
      - traefik.http.services.webapp.loadbalancer.healthcheck.path=/healthz
  
  # ðŸ° RabbitMQ Broker with UI
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    restart: unless-stopped
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS}
    networks:
      - digitalbot_internal
      - digitalbot_web
    healthcheck:
      test: [ "CMD", "rabbitmq-diagnostics", "ping" ]
      interval: 30s
      timeout: 10s
      retries: 5
    labels:
      - traefik.enable=true
      - traefik.http.routers.rabbit.rule=Host(`${RABBITMQ_DOMAIN}`)
      - traefik.http.routers.rabbit.entrypoints=websecure
      - traefik.http.routers.rabbit.tls=true
      - traefik.http.routers.rabbit.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.rabbit.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.rabbit.loadbalancer.server.port=15672
  
  # ðŸ˜ PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - digitalbot_internal
      - digitalbot_web
    ports:
      - "5432:5432"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      interval: 10s
      timeout: 5s
      retries: 5
  
  # ðŸ§‘â€ðŸ’» pgAdmin for DB Management
  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD}
    networks:
      - digitalbot_web
      - digitalbot_internal
    depends_on:
      - postgres
    healthcheck:
      test: [ "CMD", "wget", "-q", "--spider", "http://localhost/misc/ping" ]
      interval: 15s
      timeout: 10s
      retries: 6
      start_period: 60s
    labels:
      - traefik.enable=true
      - traefik.http.routers.pgadmin.rule=Host(`${PGADMIN_DOMAIN}`)
      - traefik.http.routers.pgadmin.entrypoints=websecure
      - traefik.http.routers.pgadmin.tls=true
      - traefik.http.routers.pgadmin.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.pgadmin.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.pgadmin.loadbalancer.server.port=80

  # ðŸ“Š Portainer Dashboard
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    restart: unless-stopped
    command: -H unix:///var/run/docker.sock
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer-data:/data
    networks:
      - digitalbot_web
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://localhost:9000/api/status || curl -fsS http://localhost:9000/api/status > /dev/null || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 10
      start_period: 40s
    labels:
      - traefik.enable=true
      - traefik.http.routers.portainer.rule=Host(`${PORTAINER_DOMAIN}`)
      - traefik.http.routers.portainer.entrypoints=websecure
      - traefik.http.routers.portainer.tls=true
      - traefik.http.routers.portainer.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.portainer.middlewares=default-security@file
      - traefik.http.services.portainer.loadbalancer.server.port=9000
      # SSL certificate optimization for Portainer
      - traefik.http.services.portainer.loadbalancer.server.scheme=http
      - traefik.http.routers.portainer.tls.options=default@file
    

  # ðŸ›  Background Processor
  processor:
    image: ${PROCESSER_IMAGE}
    restart: unless-stopped
    deploy:
      replicas: ${PROCESSER_REPLICAS:-1}
    environment:
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - DOMAIN=${DOMAIN}
      - CLIENT_APP_DOMAIN=${CLIENT_APP_DOMAIN}
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
    networks:
      - digitalbot_internal
      - digitalbot_web
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
  
  # ðŸ›  Order Worker
  order-worker:
    image: ${ORDER_WORKER_IMAGE}
    restart: unless-stopped
    deploy:
      replicas: ${ORDER_WORKER_REPLICAS:-1}
    environment:
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
    networks:
      - digitalbot_internal
      - digitalbot_web
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
  
  # ðŸš€ Redis for Caching
  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    command:
      - redis-server
      - --save
      - ""
      - --appendonly
      - "no"
      - --maxmemory
      - ${REDIS_MAXMEMORY:-512mb}
      - --maxmemory-policy
      - allkeys-lru
      - --requirepass
      - ${REDIS_PASSWORD}
    networks:
      - digitalbot_internal
    healthcheck:
      test: [ "CMD-SHELL", "redis-cli -a ${REDIS_PASSWORD} ping | grep PONG" ]
      interval: 5s
      timeout: 2s
      retries: 5
      
  redisinsight:
    image: redis/redisinsight:latest
    container_name: redisinsight
    restart: unless-stopped
    networks:
      - digitalbot_internal
      - digitalbot_web
    depends_on:
      - redis
    labels:
      - traefik.enable=true
      - traefik.http.routers.redisinsight.rule=Host(`${REDISINSIGHT_DOMAIN}`)
      - traefik.http.routers.redisinsight.entrypoints=websecure
      - traefik.http.routers.redisinsight.tls=true
      - traefik.http.routers.redisinsight.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.redisinsight.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.redisinsight.loadbalancer.server.port=5540

# =============================
# ðŸ”„ Volumes & Networks
# =============================
volumes:
  postgres-data:
  portainer-data:
  traefik-letsencrypt:

networks:
  digitalbot_web:
    external: true
  digitalbot_internal:
    # This network is not accessible from outside
    internal: true