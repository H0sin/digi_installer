services:
  # 🌐 Reverse Proxy & Load Balancer (Traefik)
  traefik:
    image: traefik:v3.0
    container_name: traefik
    restart: unless-stopped
    command:
      # API and Dashboard
      - --api.dashboard=true
      - --api.insecure=false
      # Entrypoints
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.traefik.address=:8080
      # Global HTTP to HTTPS redirect
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
      - --entrypoints.web.http.redirections.entrypoint.permanent=true
      # Providers
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=web
      - --providers.file.directory=/etc/traefik/dynamic
      - --providers.file.watch=true
      # Logging
      - --log.level=INFO
      - --log.format=json
      - --accesslog=true
      - --accesslog.format=json
      # Metrics
      - --metrics.prometheus=true
      - --metrics.prometheus.addEntryPointsLabels=true
      - --metrics.prometheus.addServicesLabels=true
      # Let's Encrypt HTTP-01 challenge
      - --certificatesresolvers.httpresolver.acme.email=${TRAEFIK_ACME_EMAIL}
      - --certificatesresolvers.httpresolver.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.httpresolver.acme.httpchallenge.entrypoint=web
      # Let's Encrypt DNS-01 challenge for wildcard support
      - --certificatesresolvers.dnsresolver.acme.email=${TRAEFIK_ACME_EMAIL}
      - --certificatesresolvers.dnsresolver.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.dnsresolver.acme.dnschallenge=true
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.provider=${ACME_DNS_PROVIDER:-cloudflare}
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.delaybeforecheck=30
      - --certificatesresolvers.dnsresolver.acme.dnschallenge.resolvers=1.1.1.1:53,8.8.8.8:53
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"  # Dashboard port
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik/dynamic:/etc/traefik/dynamic:ro
      - traefik-letsencrypt:/letsencrypt
    environment:
      # DNS provider credentials for wildcard certs
      - CF_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
      - CLOUDFLARE_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
    networks:
      - web
    # Remove heavy dependencies - Traefik should start independently
    # Only depend on basic infrastructure
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://localhost:8080/ping || curl -fsS http://localhost:8080/ping > /dev/null || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    labels:
      - traefik.enable=true
      # Dashboard router
      - traefik.http.routers.traefik.rule=Host(`${TRAEFIK_DOMAIN:-traefik.localhost}`)
      - traefik.http.routers.traefik.entrypoints=websecure
      - traefik.http.routers.traefik.tls=true
      - traefik.http.routers.traefik.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.traefik.service=api@internal
      - traefik.http.routers.traefik.middlewares=default-security@file,dashboard-auth@file
      # Dashboard service uses port 8080
      - traefik.http.services.traefik.loadbalancer.server.port=8080
  
  # ⚛️ React Client App
  client-app:
    image: ${CLIENT_APP_IMAGE}
    container_name: ${COMPOSE_PROJECT_NAME}-client-app
    restart: unless-stopped
    networks:
      - web
    environment:
      - VITE_BASE_API=${VITE_BASE_API}
    healthcheck:
      test: ["CMD-SHELL", "(curl -fsS http://localhost:3000/ || wget -q -O - http://localhost:3000/) > /dev/null 2>&1 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 6
      start_period: 40s
    labels:
      - traefik.enable=true
      - traefik.http.routers.client.rule=Host(`${CLIENT_APP_DOMAIN}`)
      - traefik.http.routers.client.entrypoints=websecure
      - traefik.http.routers.client.tls=true
      - traefik.http.routers.client.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.client.middlewares=default-security@file,rate-limit@file
      - traefik.http.services.client.loadbalancer.server.port=3000

  # 🌐 Main ASP.NET Core Web App
  webapp:
    image: ${WEBAPP_IMAGE}
    container_name: ${COMPOSE_PROJECT_NAME}-app
    restart: unless-stopped
    # Add resource limits to prevent crashes
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
    environment:
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - DOMAIN=${DOMAIN}
      - CLIENT_APP_DOMAIN=${CLIENT_APP_DOMAIN}
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
      # Add debugging environment variables
      - ASPNETCORE_URLS=http://+:8080
      - DOTNET_USE_POLLING_FILE_WATCHER=1
      - DOTNET_RUNNING_IN_CONTAINER=true
    networks:
      - web
      - internal
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:8080/healthz > /dev/null || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 6
      start_period: 60s
    labels:
      - traefik.enable=true
      - traefik.http.routers.webapp.rule=Host(`${DOMAIN}`)
      - traefik.http.routers.webapp.entrypoints=websecure
      - traefik.http.routers.webapp.tls=true
      - traefik.http.routers.webapp.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.webapp.middlewares=default-security@file,rate-limit@file
      - traefik.http.services.webapp.loadbalancer.server.port=8080
      - traefik.http.services.webapp.loadbalancer.healthcheck.path=/healthz
  
  # 🐰 RabbitMQ Broker with UI
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    restart: unless-stopped
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS}
    networks:
      - internal
      - web
    healthcheck:
      test: [ "CMD", "rabbitmq-diagnostics", "ping" ]
      interval: 30s
      timeout: 10s
      retries: 5
    labels:
      - traefik.enable=true
      - traefik.http.routers.rabbit.rule=Host(`${RABBITMQ_DOMAIN}`)
      - traefik.http.routers.rabbit.entrypoints=websecure
      - traefik.http.routers.rabbit.tls=true
      - traefik.http.routers.rabbit.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.rabbit.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.rabbit.loadbalancer.server.port=15672
  
  # 🐘 PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - internal
      - web
    ports:
      - "5432:5432"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      interval: 10s
      timeout: 5s
      retries: 5
  
  # 🧑‍💻 pgAdmin for DB Management
  pgadmin:
    image: dpage/pgadmin4
    container_name: pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD}
    networks:
      - web
      - internal
    depends_on:
      - postgres
    healthcheck:
      test: [ "CMD", "wget", "-q", "--spider", "http://localhost/misc/ping" ]
      interval: 15s
      timeout: 10s
      retries: 6
      start_period: 60s
    labels:
      - traefik.enable=true
      - traefik.http.routers.pgadmin.rule=Host(`${PGADMIN_DOMAIN}`)
      - traefik.http.routers.pgadmin.entrypoints=websecure
      - traefik.http.routers.pgadmin.tls=true
      - traefik.http.routers.pgadmin.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.pgadmin.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.pgadmin.loadbalancer.server.port=80

  # 📊 Portainer Dashboard
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    restart: unless-stopped
    command: -H unix:///var/run/docker.sock
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer-data:/data
    networks:
      - web
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://localhost:9000/api/status || curl -fsS http://localhost:9000/api/status > /dev/null || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 10
      start_period: 40s
    labels:
      - traefik.enable=true
      - traefik.http.routers.portainer.rule=Host(`${PORTAINER_DOMAIN}`)
      - traefik.http.routers.portainer.entrypoints=websecure
      - traefik.http.routers.portainer.tls=true
      - traefik.http.routers.portainer.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.portainer.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.portainer.loadbalancer.server.port=9000
    

  # 🛠 Background Processor
  processor:
    image: ${PROCESSER_IMAGE}
    restart: unless-stopped
    deploy:
      replicas: ${PROCESSER_REPLICAS:-1}
    environment:
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - DOMAIN=${DOMAIN}
      - CLIENT_APP_DOMAIN=${CLIENT_APP_DOMAIN}
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
    networks:
      - internal
      - web
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
  
  # 🛠 Order Worker
  order-worker:
    image: ${ORDER_WORKER_IMAGE}
    restart: unless-stopped
    deploy:
      replicas: ${ORDER_WORKER_REPLICAS:-1}
    environment:
      - RabbitMq__HOST=rabbitmq
      - RabbitMq__Username=${RABBITMQ_USER}
      - RabbitMq__Password=${RABBITMQ_PASS}
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      - ASPNETCORE_ENVIRONMENT=Production
      - Redis__Host=redis
      - Redis__Port=6379
      - Redis__Password=${REDIS_PASSWORD}
      - Redis__AbortConnect=false
      - Redis__DefaultAbsoluteExpirationSeconds=300
      - TelegramLogger__BotToken=${TELEGRAMLOGGER__BOTTOKEN}
      - TelegramLogger__ChatId=${TELEGRAMLOGGER__CHATID}
      - TelegramLogger__Topics__Default=${TELEGRAMLOGGER__TOPICS__DEFAULT}
      - TelegramLogger__Topics__Information=${TELEGRAMLOGGER__TOPICS__INFORMATION}
      - TelegramLogger__Topics__Warning=${TELEGRAMLOGGER__TOPICS__WARNING}
      - TelegramLogger__Topics__Error=${TELEGRAMLOGGER__TOPICS__ERROR}
      - TelegramLogger__Topics__Critical=${TELEGRAMLOGGER__TOPICS__CRITICAL}
      - TelegramLogger__Topics__Orders=${TELEGRAMLOGGER__TOPICS__ORDERS}
      - TelegramLogger__Topics__Payments=${TELEGRAMLOGGER__TOPICS__PAYMENTS}
    networks:
      - internal
      - web
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
  
  # 🚀 Redis for Caching
  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    command:
      - redis-server
      - --save
      - ""
      - --appendonly
      - "no"
      - --maxmemory
      - ${REDIS_MAXMEMORY:-512mb}
      - --maxmemory-policy
      - allkeys-lru
      - --requirepass
      - ${REDIS_PASSWORD}
    networks:
      - internal
    healthcheck:
      test: [ "CMD-SHELL", "redis-cli -a ${REDIS_PASSWORD} ping | grep PONG" ]
      interval: 5s
      timeout: 2s
      retries: 5
      
  redisinsight:
    image: redis/redisinsight:latest
    container_name: redisinsight
    restart: unless-stopped
    networks:
      - internal
      - web
    depends_on:
      - redis
    labels:
      - traefik.enable=true
      - traefik.http.routers.redisinsight.rule=Host(`${REDISINSIGHT_DOMAIN}`)
      - traefik.http.routers.redisinsight.entrypoints=websecure
      - traefik.http.routers.redisinsight.tls=true
      - traefik.http.routers.redisinsight.tls.certresolver=${TRAEFIK_CERT_RESOLVER:-httpresolver}
      - traefik.http.routers.redisinsight.middlewares=default-security@file,admin-auth@file
      - traefik.http.services.redisinsight.loadbalancer.server.port=5540

# =============================
# 🔄 Volumes & Networks
# =============================
volumes:
  postgres-data:
  portainer-data:
  traefik-letsencrypt:

networks:
  web:
    external: true
    name: web
  internal:
    # This network is not accessible from outside
    internal: true